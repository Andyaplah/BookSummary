**Hash table，也叫散列表**

**对应关系f称为散列函数，又称为哈希（Hash函数）**



**数组的特点是：寻址容易，插入和删除困难；**

**而链表的特点是：寻址困难，插入和删除容易**

**两者的特性，做出一种寻址容易，插入删除也容易的数据结构**

**哈希表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法——拉链法，我们可以理解为“链表的数组”，如图**

![image-20200626100108513](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/image-20200626100108513.png)



优点：不论哈希表中有多少数据，查找、插入、删除（有时包括删除）只需要接近常量的时间即0(1）的时间级。实际上，这只需要几条机器指令。

哈希表运算得非常快，在计算机程序中，如果需要在一秒种内查找上千条记录通常使用哈希表（例如拼写检查器)哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。

如果不需要有序遍历数据，并且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的

---

**三种比较常用的**

**1，除法散列法 
最直观的一种，上图使用的就是这种散列法，公式： 
   index = value % 16 
学过汇编的都知道，求模数其实是通过一个除法运算得到的，所以叫“除法散列法”。**



2，平方散列法 
求index是非常频繁的操作，而乘法的运算要比除法来得省时（对现在的CPU来说，估计我们感觉不出来），所以我们考虑把除法换成乘法和一个位移操作。公式： 
      index = (value * value) >> 28   （右移，除以2^28。记法：左移变大，是乘。右移变小，是除。）
如果数值分配比较均匀的话这种方法能得到不错的结果，但我上面画的那个图的各个元素的值算出来的index都是0——非常失败。也许你还有个问题，value如果很大，value * value不会溢出吗？答案是会的，但我们这个乘法不关心溢出，因为我们根本不是为了获取相乘结果，而是为了获取index









**缺点：它是基于数组的，数组创建后难于扩展，某些哈希表被基本填满时，性能下降得非常严重，所以程序员必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）**





----

解决hash碰撞的两种方法

## 线性探测法

![image-20200626095315369](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/image-20200626095315369.png)

#### 32原本也应该放在余数为0的位置，但是余数为0的地方已经有数字了，就向后一位放到余数为1的位置。假设下一次放64，那么64就放到余数为2的地方，这样查找64，只需要3次，也就找到了。复杂度还是比单链表的O（n）要快很多。用代码来表示是这样的







有两种方法：一是链式扩展；二是开放寻址

链式扩展:

把具有相同hash值的元素放到一起，形成一个链表































---------------------算法题---环路检测------------

![image-20200626112511282](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/image-20200626112511282.png)

作者很牛逼，我整理一下思路： 1.利用快慢指针判断有没有环 2.如果有，则快慢指针会在某点相遇，因为快指针多跑了，但相遇的点不一定是环的入口。 3.不妨设链表的头节点到环的入口节点的距离为s1，入口节点到二者相遇点的距离为s2 3.我们得到这样一个各自所跑的距离 4.快指针移动的距离是y1=（ s1+s2+xn）快指针先从头节点跑到相遇节点，然后在环里不断的跑，x为跑的圈数，直到遇到慢指针 5. 满指针移动的距离是y2=（s1+s2）慢指针从头节点跑到二者相遇的阶段 6.二者存在一个潜在的等量关系，y1=2y2，即是（s1+s2+xn)=2(s1+s2) 7.整理一下s1+s2=xn; 8.进一步整理：s1=（n-s2）+（x-1）n 9.快指针移动s1步，到达入口，慢指针也移动s1步，换算成上面这个等式，(x-1)n等于绕圈，没动，实际移动了（n-s2），也到达了入口。 10.此时返回慢指针所指位置，就是入口。





ListNode *detectCycle(ListNode *head) {
        if(!head||!head->next)
        {
            return NULL;
        }
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast&&fast->next)
        {
            slow=slow->next;
            fast=fast->next->next;
            if(fast==slow)
            {
                break;
            }
        }
        if(fast!=slow)
        {
            return NULL;
        }
        fast=head;
        while(fast!=slow)
        {
            fast=fast->next;
            slow=slow->next;
        }
        return fast;
    }

